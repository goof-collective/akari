[[messages]]
== Message Format

All communication between the Controller and clients over the primary <<transport-uds, Unix Domain Socket transport>> MUST use messages serialized with FlatBuffers according to the schemas defined herein.

[[message-schema,Message Schema]]
=== Structure

[[message-header, MessageHeader]]
.MessageHeader
|===
| Name | Type | Description

| `id`
| `uint32`
| *Required:* Sender's unique sequential message ID.

| `target`
| `[uint32]`
| *Required:* Recipient ID. See semantics below.

| `type`
| `uint16`
| *Required:* Identifies the message body.

| `status`
| `uint8`
| Status code (0=success, others indicate errors)

| `reply_to`
| `uint32`
| ID of the message being replied to (0 if none)
|===

`id`::
  A unique sequential identifier for the message, generated by the *sender*. IDs MUST be unique within the context of a single connection and SHOULD increment monotonically (wrapping around is permissible). Primarily used for matching replies (via `reply_to`).
`targets`::
  A list of `uint32` values identifying the intended recipient(s). This field MUST NOT be null, but MAY be empty. The ID `0` represents the Controller itself. The interpretation is as follows:
  * `[]` (empty list) -- *Broadcast.* The sender requests the Controller to broadcast this message. The Controller MUST determine the appropriate set of recipients based on the sender's role and permissions, then send the messages individually to the recipients.
  * `[0]` -- *Controller Target.* The message is intended exclusively for processing by the Controller itself.
  * `[ClientID]` -- *Unicast.* The message targets a single specific client (Application or Manager) with the given `ClientID` (where `ClientID > 0`).
  * `[ClientID1, ClientID2, ...]`: *Multicast.* The message targets multiple specific clients. The list MUST NOT contain duplicates and MUST NOT contain `0` if other ClientIDs are present.

.Message
|===
| Name | Type | Description

| `header`
| <<message-header>>
| *Required:* Contains metadata of the message

| `body`
| `[ubyte]`
| *Required:* An opaque payload. Interpretation depends on `header.type`. MUST be validated by the *recipient* based on the type.
|===

=== Constraints

* *Replies/Statuses are Unicast:* If the `reply_to` field is non-zero OR the `status` field is non-zero, the `targets` list MUST contain exactly one element, and that element MUST be a `ClientID` greater than 0. Replies and status updates are always unicast to a specific client.
* *Application Sending Restrictions:* As defined in <<communication-constraints>>, Applications MUST only send messages where `targets` is `[0]` (i.e., messages directed only to the Controller). They MUST NOT send messages with specific ClientIDs or empty (Broadcast) `targets`.

=== Message Replies

Within Akari, interactions often follow a request-response pattern, although many messages (like notifications or events) do not require a direct reply.

Requests:: A message initiating an operation or query MAAY implicitly or explicitly require a response.
Responses:: A message is considered a response _if and only if_ its `MessageHeader.reply_to` field contains the `id` of a previously sent Request message.

For any given Request message, the recipient MUST send at most one Response message.

The `MessageHeader.status` field in a Response message indicates the outcome of an operation requested by the original message.

[[message-verification]]
=== Verification

For security against malicious messages, implementations MUST validate every received message using the FlatBuffers Verifier *before* attempting to access any data fields via the FlatBuffers API.

1. Upon receiving a byte buffer from the UDS socket, the receiver MUST run the FlatBuffers Verifier using the defined <<message-schema>> as the expected root type.
2. If this initial verification fails:
  * The message is structurally invalid and its contents cannot be trusted.
  * The message MUST be discarded immediately.
  * No data access MUST be attempted. 
  * An error SHOULD be logged, potentially including the source if known. 
  * If the receiving component is the Controller and the sender is a client, the Controller MAY choose to disconnect the client if invalid messages persist.
  * *No Response or Error message MUST be sent back in this case.*
3. If outer verification passes, the `header` fields can be safely accessed.
4. The `body` byte slice can be safely accessed (its offset/length are valid).
5. The content of the `body` MUST then be validated by the ultimate recipient based on the `header.type`:
  * If the `body` is expected to contain another FlatBuffers message (recommended), the FlatBuffers verifier MUST be run again on the `body` slice using the appropriate schema before accessing its contents. Failure of this verification means the message body is invalid.
  * If the `body` contains non-FlatBuffers data, manual validation MUST be performed. Failure means the body is invalid.
  * Even if the `body` is structurally valid, the recipient MUST perform semantic validation on the contained data (e.g., checking if IDs exist, values are in rage, requested operation is permitted by rules/permissions). Failure means the request is invalid or disallowed.
6. If the outer message passed verification, but the `body` fails validation or represents a semantically invalid/disallowed request:
  * The request is considered invalid or disallowed.
  * If the original message normally expects a response, the receiver SHOULD send a <<message-replies, Response message>> back to the original sender.
    * This Response must set the `status` to a non-zero error code (e.g., <<err-InvalidMessage,Invalid Message>>, <<err-Unauthorized,Unauthorized>>).
  * If the original message did not normally expect a response, the receiver MAY simply discard the message with the invalid body and log the error.

